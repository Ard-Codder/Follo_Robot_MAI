Follo_Robot_MAI - это часть проекта Follo по созданию системы, нацеленной на уборку территорий 
с помощью беспилотных технологий.

Про object_folowwing.py:
    Этот код представляет собой систему отслеживания объектов с использованием камеры Raspberry Pi и TensorFlow Lite. Система позволяет отслеживать выбранный объект и управлять движением робота, на котором установлена камера, с помощью веб-интерфейса.
    В начале кода импортируются необходимые библиотеки и модули, такие как OpenCV, NumPy, PIL, Flask и RPi.GPIO. Затем инициализируется камера и загружается модель TensorFlow Lite для обнаружения объектов. Далее определяются параметры для отслеживания объектов и список допустимых объектов для отслеживания.
    Функция track_object() отвечает за отслеживание выбранного объекта. Она получает список обнаруженных объектов и их меток, выбирает нужный объект и вычисляет его координаты и отклонение от центра изображения. Затем функция запускает поток для управления движением робота
    Функция move_robot() отвечает за управление движением робота. Она получает текущее отклонение объекта от центра изображения и выбирает нужное действие: движение вперед, влево, вправо или остановку. Затем функция вызывает соответствующие функции для управления моторами робота.
    Функция draw_overlays() отвечает за наложение графических элементов на изображение, таких как координаты объекта, отклонение от центра, текущая команда управления и скорость.
    Функция main() запускает веб-сервер с помощью Flask и передает поток видео с камеры на веб-страницу. В цикле она получает изображение с камеры, обрабатывает его с помощью TensorFlow Lite, отслеживает объект, накладывает графические элементы и передает изображение на веб-страницу.
    В целом, этот код представляет собой полноценную систему отслеживания объектов с использованием TensorFlow Lite и веб-интерфейса для управления роботом.

В папке client находятся:
- main.py - использует библиотеки tornado и communication_with_the_server для отправки и получения данных через веб-сокеты.
    Сначала код импортирует необходимые библиотеки и создает экземпляр класса WebSocketClient из communication_with_the_server.
    Затем определяется асинхронная функция main, которая устанавливает соединение с веб-сокетом 
    по адресу "ws://localhost:8888/obtaining_drone_data", отправляет строку '5' и ожидает получения данных. 
    После получения данных, печатается сообщение 'Client disconnect' и текущий цикл событий tornado останавливается.
    Функция run_main вызывает функцию main и останавливает цикл событий tornado после её завершения.
    В конце кода, функция run_main добавляется в текущий цикл событий tornado с помощью метода add_callback и цикл 
    событий запускается с помощью метода star

- communication_with_server.py - использует библиотеку tornado для отправки и получения данных через веб-сокеты.
    Здесь определен класс WebSocketClient, который имеет три метода:
    __init__: Инициализирует атрибут ws как None.
    connect: Асинхронный метод, который устанавливает соединение с веб-сокетом по адресу ws_address. 
    Если соединение установлено успешно, печатается сообщение "Connected to server". Если происходит ошибка при
    установке соединения, печатается сообщение об ошибке.
    send_data: Асинхронный метод, который отправляет данные на сервер через веб-сокет. Если веб-сокет существует, 
    данные отправляются с помощью метода write_message, и печатается сообщение "Sent data to server: {data}".
    receive_data: Асинхронный метод, который ожидает получения данных от сервера через веб-сокет. Когда данные получены, 
    они печатаются с помощью сообщения "Received data from server: {msg}".
    Этот класс может быть использован для отправки и получения данных через веб-сокеты в асинхронном режиме с помощью 
    библиотеки tornado.

- test.py - использует библиотеку Flask для создания веб-приложения.
   Здесь создается экземпляр класса Flask, который представляет собой объект приложения Flask.
   Затем определяется функция home, которая является обработчиком маршрута /. Когда пользователь переходит по 
   адресу http://localhost:5000/ в своем браузере, эта функция вызывается и возвращает HTML-код, который отображается
   в браузере.
   Функция render_template используется для генерации HTML-кода на основе шаблона index.html. Шаблон index.html должен 
   находиться в папке templates в том же каталоге, что и этот код.
   В конце кода проверяется, запускается ли этот код как основной модуль (т.е. с помощью команды python filename.py), 
   и если да, то вызывается метод run объекта приложения Flask. Этот метод запускает веб-сервер и начинает прослушивать 
   входящие запросы на адресе http://localhost:5000/.

В папке server находятся:
- communication_with_server.py - использует библиотеку tornado для создания веб-сокет сервера.
  В этом файле определена функция make_app, которая возвращает экземпляр приложения tornado.web.Application. В списке, передаваемом в конструктор приложения, указаны два маршрута:
  r"/obtaining_drone_data" - маршрут для веб-сокета, обрабатывается классом WebSocketHandler, импортированным из модуля obtaining_drone_data.
  r"/.*" - маршрут для всех остальных запросов, обрабатывается классом NotFoundHandler, импортированным из модуля NotFoundHandler.
  В конце кода проверяется, запускается ли этот код как основной модуль (т.е. с помощью команды python filename.py), и если да, то вызывается функция make_app, создается экземпляр приложения, прослушивается порт 8888 и запускается цикл событий tornado с помощью метода start. При запуске сервера, в консоли выводится сообщение "WebSocket server started".

- NotFoundHandler.py - использует библиотеку tornado для создания обработчика запросов, который возвращает код состояния HTTP 404 Not Found и сообщение "404: Not Found" для всех запросов, которые не соответствуют другим маршрутам.
  Здесь определен класс NotFoundHandler, который наследуется от класса tornado.web.RequestHandler. В этом классе переопределен метод get, который вызывается при обработке GET-запросов. В этом методе устанавливается код состояния HTTP 404 с помощью метода set_status, и отправляется сообщение "404: Not Found" с помощью метода write.
  Этот класс может быть использован в качестве обработчика запросов для всех маршрутов, которые не соответствуют другим маршрутам, определенным в приложении. Например, в предыдущем коде, который я отправил, класс NotFoundHandler использовался для обработки всех запросов, которые не соответствовали маршруту "/obtaining_drone_data".

- obtaining_drone_data.py - использует библиотеку tornado для создания веб-сокет сервера, который отправляет сообщения всем подключенным клиентам.
  В этом файле определен класс WebSocketHandler, который наследуется от класса tornado.websocket.WebSocketHandler. В этом классе переопределены три метода:
  open - вызывается при установлении нового соединения веб-сокета. В этом методе проверяется, что текущий экземпляр класса WebSocketHandler еще не добавлен в список clients, и добавляет его туда. Затем выводится сообщение "New client connected".
  on_message - вызывается при получении нового сообщения от клиента. В этом методе сообщение, полученное от клиента, отправляется всем клиентам, которые находятся в списке clients, с помощью метода write_message.
  on_close - вызывается при закрытии соединения веб-сокета. В этом методе проверяется, что текущий экземпляр класса WebSocketHandler находится в списке clients, и удаляет его из него. Затем выводится сообщение "Client disconnected".
  В начале файла определен пустой список clients, который будет хранить всех подключенных клиентов.
  Этот класс может быть использован в качестве обработчика веб-сокетов для маршрута, определенного в приложении. Например, в предыдущем коде, который я отправил, класс WebSocketHandler использовался для обработки веб-сокетов для маршрута "/obtaining_drone_data".

- read_data.py и write_data.py - предназначены для чтения и записи данных в CSV-файл с использованием модулей csv, time, msvcrt и os.
  В первом файле определена функция read_data(), которая читает данные из CSV-файла, расположенного по пути '../server/drone_information.csv'. Функция использует менеджер контекста with для открытия файла в режиме чтения ('r') и создает объект csv.reader для чтения данных из файла. Затем функция выводит каждую строку данных на экран с помощью цикла for и функции print().
  Во втором файле определена функция write_data(data), которая записывает данные в CSV-файл, расположенный по пути '../server/drone_information.csv'. Функция использует менеджер контекста with для открытия файла в режиме записи ('w') с новым переводом строки ('newline') и создает объект csv.writer для записи данных в файл. Затем функция записывает каждую строку данных в файл с помощью цикла for и метода writerow().
  В обоих файлах перед открытием файла с помощью менеджера контекста with вызывается функция msvcrt.locking() для блокировки файла на запись или чтение. Это делается для предотвращения одновременного доступа к файлу несколькими процессами или потоками, что может привести к повреждению или потере данных. Функция msvcrt.locking() принимает три аргумента: дескриптор файла, тип блокировки (LK_LOCK для блокировки или LK_UNLCK для разблокировки) и размер блокировки (в байтах). В этом коде размер блокировки вычисляется с помощью функции os.path.getsize(), которая возвращает размер файла в байтах.
  В конце первого файла вызывается функция time.sleep(0.5) для паузы в 0.5 секунды перед завершением работы скрипта. Во втором файле функция time.sleep(0.5) вызывается внутри цикла for для паузы между записями данных в файл. Цикл for выполняется 10000000 раз, что может привести к записи большого количества данных в файл и, как следствие, к увеличению времени выполнения скрипта и потенциальным проблемам с производительностью.
  В целом, этот код может быть использован для чтения и записи данных в CSV-файл с использованием модулей csv, time, msvcrt и os. Однако, следует учесть потенциальные проблемы с производительностью и безопасностью данных при одновременном доступе к файлу несколькими процессами или потоками.

В папке drone находятся:
- папка working_with_hardware - в ней находятся примеры кода работы с различными датчиками

- main_drone.py - предназначен для управления роботом AlphaBot с помощью библиотеки RPi.GPIO.
  В начале кода импортируются необходимые библиотеки: RPi.GPIO для управления выводами GPIO на Raspberry Pi, и time для пауз между командами.
  Затем определяется класс AlphaBot, который содержит методы для управления роботом. В конструкторе класса определяются выводы GPIO для управления двигателями робота (IN1, IN2, IN3, IN4, ENA, ENB), и устанавливается режим работы GPIO.BCM. Затем выводы GPIO настроены на выход.
  Далее определены методы для управления роботом: forward() для движения вперед, stop() для остановки, backward() для движения назад, left() для поворота налево, и right() для поворота направо. В каждом методе устанавливаются соответствующие значения выводов GPIO для управления двигателями робота.
  В конце кода создается экземпляр класса AlphaBot, и вызываются методы для управления роботом с паузами между командами.
  При запуске кода, робот AlphaBot будет выполнять последовательность команд: движение вперед, остановка, движение назад, поворот налево, и поворот направо.

В папке Segmentation находится пример кода сегментации с помощью нейронки LangSAM

В папке Tracing находится пример видеотрекинга с использованием алгоритма ByteTrack

В папке Test находится мусор
